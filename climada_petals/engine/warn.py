import logging
import copy
from dataclasses import dataclass

import numpy as np
import skimage

LOGGER = logging.getLogger(__name__)


@dataclass
class FilterData:
    """FilterData data class definition. It stores the relevant information needed during the warning generation.
    The operations and its sizes, as well as the algorithms properties (gradual decrease of warning levels and
    changing of small warning regions formed) are saved.

    Attributes
    ----------
    warn_levels : np.array
        Warn levels that define the bins in which the input_map will be classified in.
    operations : list
        Operations to be applied in filtering algorithm.
        Possible values: 'DILATION', 'EROSION', 'MEDIANFILTERING'.
    sizes : list
        Size of kernel of every operation given.
    gradual_decr : bool
        Used to define whether the highest warn levels should be gradually decreased (if True)
        to the lowest level (e.g., level 3, 2, 1, 0)
        or larger steps are allowed (e.g., from warn level 5 directly to 1).
    change_sm : bool
        If True, the levels of too small regions are changed to its surrounding levels.
    size_sm : int
        Defining what too small regions are. Number of coordinates.
    """
    # Explanation of defaults (also maybe transfer to config, talk to Emanuel)
    OPERATIONS = ['DILATION', 'EROSION', 'DILATION', 'MEDIANFILTERING']
    SIZES = [2, 3, 7, 15]
    GRADUAL_DECREASE = True
    CHANGE_SMALL_REGIONS = True
    SIZE_TOO_SMALL = 150

    def __init__(self, warn_levels, operations=OPERATIONS, sizes=SIZES,
                 gradual_decr=GRADUAL_DECREASE, change_sm=CHANGE_SMALL_REGIONS, size_sm=SIZE_TOO_SMALL):
        """Initialize FilterData."""
        self.warn_levels = warn_levels
        self.gradual_decr = gradual_decr
        if len(operations) != len(sizes):
            LOGGER.warning('For every operation a filter size is needed and the other way around. '
                           'Please input the same number of operations and filter sizes.')
        if not all(item in ['DILATION', 'EROSION', 'MEDIANFILTERING'] for item in operations):
            raise ValueError("The operation is not defined. "
                             "Please select 'EROSION', 'DILATION', or 'MEDIANFILTERING'.")

        self.operations = operations
        self.sizes = sizes
        self.change_sm = change_sm
        self.size_sm = size_sm


class Warn:
    """Warn definition. Generate a warning, i.e., 2D map of points with assigned warn levels. Operations, their order,
    and their influence (kernel sizes) can be selected to fit the users purpose. Further properties can be chosen which
    define the warning generation. The functionality of reducing heterogeneity in a map can be applied to different
    inputs, e.g. MeteoSwiss windstorms, TCs, impacts, etc.

    Attributes
    ----------
    warning : np.array
        Warning generated by class. Warn level for every point of input map.
    coord : np.array
        Coordinates of warning map.
    warn_levels : list
        Warn levels that define the bins in which the input_map will be classified in.
    """

    def __init__(self, warning, coord, filter_data):
        """Initialize Warn.

        Parameters
        ----------
        warning : np.array
            Warn level for every point of input map.
        coord : np.array
            Coordinates of warning map.
        warn_levels : list
            Warn levels that define the bins in which the input_map will be classified in.
        """
        self.warning = warning
        self.coord = coord
        self.warn_levels = filter_data.warn_levels

    @classmethod
    def from_map(cls, input_map, coord, filter_data):
        """Generate Warn object from np.array.

        Parameters
        ----------
        input_map : np.array
            2d map of values which are used to generate the warning.
        coord : np.array
            Coordinates of warning map.
        filter_data : dataclass
            Dataclass consisting information on how to generate the warning (operations and details).

        Returns
        ----------
        warn : Warn
            Generated Warn object including warning, coordinates, and warn levels.
        """
        binned_map = cls.bin_map(input_map, filter_data.warn_levels)
        warning = cls.filter_algorithm(binned_map, filter_data)
        if filter_data.change_sm:
            warning = cls.change_small_regions(warning, filter_data.size_sm)
        return cls(warning, coord, filter_data)

    @staticmethod
    def bin_map(input_map, warn_levels):
        """Bin every value of input map into given warn levels.

        Parameters
        ----------
        input_map : np.array
            Array containing data to generate warning of.
        warn_levels : np.array
            Array containing data to generate warning of.

        Returns
        ----------
        binned_map : np.array
            Map of binned values in warn levels, same shape as input map.
        """
        if np.min(input_map) < np.min(warn_levels):
            LOGGER.warning('Values of input map are smaller than defined warn levels. '
                           'Please set the warn levels lower or check input map.')
        if np.min(input_map) > np.min(warn_levels):
            LOGGER.warning('Values of input map are larger than defined warn levels. '
                           'Please set the warn levels higher or check input map.')
        return np.digitize(input_map, warn_levels) - 1  # digitize lowest bin is 1

    @staticmethod
    def dilation(bin_m, size):
        return skimage.morphology.dilation(bin_m, skimage.morphology.disk(size))

    @staticmethod
    def erosion(bin_m, size):
        return skimage.morphology.erosion(bin_m, skimage.morphology.disk(size))

    @staticmethod
    def median_filtering(bin_m, size):
        return skimage.filters.median(bin_m, np.ones((size, size)))

    @staticmethod
    def filtering(binary_curr_lvl, filter_data):
        """For the current warn level, apply defined operations in filter data on the input map.

        Parameters
        ----------
        binary_curr_lvl : np.array
            Binary array, where 1 corresponds to current (and higher if grad_decrease) warn level and 0 else.
        filter_data : dataclass
            Dataclass consisting information on how to generate the warning (operations and details).

        Returns
        ----------
        binary_curr_lvl : np.array
            Warning map consisting formed warning regions of current warn level, same shape as input map.
        """
        allowed_operations = {
            'DILATION': Warn.dilation,
            'EROSION': Warn.erosion,
            'MEDIANFILTERING': Warn.median_filtering
        }
        # apply defined operations
        for i, op in enumerate(filter_data.operations):
            binary_curr_lvl = allowed_operations.get(op)(binary_curr_lvl, filter_data.sizes[i])

        return binary_curr_lvl

    @staticmethod
    def filter_algorithm(bin_map, filter_data):
        """Generate warning map of binned map. The filter algorithm reduces heterogeneity in the map (erosion) and
        makes sure warn regions of higher warn levels warn regions large enough (dilation). With the median
        filtering the generated warning is smoothed out without blurring.

        Parameters
        ----------
        bin_map : np.array
            Map of binned values in warn levels. Hereof a warning with contiguous regions is formed.
        filter_data : dataclass
            Dataclass consisting information on how to generate the warning (operations and details).

        Returns
        ----------
        warn_regions : np.array
            Warning map consisting formed warning regions, same shape as input map.
        """
        max_warn_level = np.max(bin_map)
        if max_warn_level == 0:
            return np.zeros_like(bin_map)

        warn_map = 0
        # iterate from highest level to lowest (0 not necessary, because rest is level 0)
        for curr_lvl in range(max_warn_level, 0, -1):

            # select only the current warn level (no gradual decrease in warn map) or select current and higher warn
            # levels for a gradual decrease. Binary map allows to apply binary filtering operations
            if filter_data.gradual_decr:
                pts_curr_lvl = np.bitwise_or(warn_map, bin_map >= curr_lvl)
            else:
                pts_curr_lvl = bin_map == curr_lvl
            binary_curr_lvl = np.where(pts_curr_lvl, curr_lvl, 0)  # set everything but selected points to 0

            w_l = Warn.filtering(binary_curr_lvl, filter_data)
            warn_map = np.maximum(warn_map, w_l)  # keep warn regions of higher levels by taking maximum

        return warn_map

    @staticmethod
    def increase_levels(warn, size):
        """Increase warn levels of too small regions to max warn level of this warning.

        Parameters
        ----------
        warn : np.array
            Warning map of which too small regions are changed to surrounding. Warn levels are all +1.
        size : int
            Threshold defining too small regions (number of grid points).

        Returns
        ----------
        warn : np.array
            Warning map where too small regions are of the higher level occurring. Warn levels are all +1.
        """
        labels = skimage.measure.label(warn)
        for i in range(np.max(labels)):
            cnt = np.count_nonzero(labels == i)
            if cnt <= size:
                warn[labels == i] = np.max(warn, axis=(0, 1))
        return warn

    @staticmethod
    def set_new_levels(warn, size):
        """Set warn levels of too small regions to highest surrounding warn level. Therefore, decrease warn levels of
        too small regions, until no too small regions can be detected.

        Parameters
        ----------
        warn : np.array
            Warning map of which too small regions are changed to surrounding. Warn levels are all +1.
        size : int
            Threshold defining too small regions (number of grid points).

        Returns
        ----------
        warn : np.array
            Warning map where too small regions are changed to neighborhood. Warn levels are all +1.
        """
        for i in range(np.max(warn), np.min(warn), -1):
            level = copy.deepcopy(warn)
            level[warn != i] = 0
            labels = skimage.measure.label(warn)
            for j in range(len(np.unique(labels)) + 1):
                cnt = np.count_nonzero(labels == j)
                if cnt <= size:
                    warn[labels == j] = i - 1
        return warn

    @staticmethod
    def change_small_regions(warning, size):
        """Change regions smaller than defined threshold from warning to surrounding warn level.

        Parameters
        ----------
        warning : np.array
            Warning map of which too small regions are changed to surrounding.
        size : int
            Threshold defining too small regions (number of grid points).

        Returns
        ----------
        warning : np.array
            Warning without too small regions.
        """
        warning = warning + 1  # 0 is regarded as background in labelling, + 1 prevents this
        warning = Warn.increase_levels(warning, size)
        warning = Warn.set_new_levels(warning, size)
        warning = warning - 1
        return warning
