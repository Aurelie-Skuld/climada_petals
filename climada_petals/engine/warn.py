import logging
import copy
from dataclasses import dataclass

import numpy as np
import skimage

LOGGER = logging.getLogger(__name__)


@dataclass
class FilterData:
    """FilterData data class definition. It stores the relevant information needed during the warning generation.
    The operations and its sizes, as well as the algorithms properties (gradual decrease of warning levels and
    changing of small warning regions formed) are saved.

    Attributes
    ----------
    warn_levels : np.array
        Warn levels that define the bins in which the input_map will be classified in.
    operations : list
        Type of operations to be applied in filtering algorithm.
        Possible values: 'DILATION', 'EROSION', 'MEDIANFILTERING'
    sizes : list
        Size of kernel of every operation given.
    gradual_decr : bool
        Used to define whether the highest warn levels should be gradually decreased (if True)
        to the lowest level (e.g., level 3, 2, 1, 0)
        or larger steps are allowed (e.g., from warn level 5 directly to 1)
    change_sm : bool
        If True, the levels of too small regions are changed to its surrounding levels
    size_sm : int
        Defining what too small regions are. Number of coordinates
    """
    # Explanation of defaults (also maybe transfer to config, talk to Emanuel)
    OPERATIONS = ['DILATION', 'EROSION', 'DILATION', 'MEDIANFILTERING']
    SIZES = [2, 3, 7, 15]
    GRADUAL_DECREASE = True
    CHANGE_SMALL_REGIONS = True
    SIZE_TOO_SMALL = 150

    def __init__(self, warn_levels, operations=OPERATIONS, sizes=SIZES,
                 gradual_decr=GRADUAL_DECREASE, change_sm=CHANGE_SMALL_REGIONS, size_sm=SIZE_TOO_SMALL):
        """Initialize FilterData."""
        self.warn_levels = warn_levels
        self.gradual_decr = gradual_decr
        if len(operations) != len(sizes):
            LOGGER.warning('For every operation a filter size is needed and the other way around. '
                           'Please input the same number of operations and filter sizes.')
        if not all(item in ['DILATION', 'EROSION', 'MEDIANFILTERING'] for item in operations):
            raise ValueError("The operation is not defined. "
                           "Please select 'EROSION', 'DILATION', or 'MEDIANFILTERING'.")

        self.operations = operations
        self.sizes = sizes
        self.change_sm = change_sm
        self.size_sm = size_sm


class Warn:
    """Warn definition. Generate a warning, i.e., 2D map of points with assigned warn levels. Operations, their order,
    and their influence (kernel sizes) can be selected to fit the users purpose. Further properties can be chosen which
    define the warning generation. The functionality of reducing heterogeneity in a map can be applied to different
    inputs, e.g. MeteoSwiss windstorms, TCs, impacts, etc.

    Attributes
    ----------
    warning : np.array
        Warning generated by class. Warn level for every point of input map.
    coord : np.array
        Coordinates of warning map.
    warn_levels : list
        Warn levels that define the bins in which the input_map will be classified in.
    """

    # operations that can be applied in filtering algorithm
    filtering_operations = {
        "DILATION": lambda bin_m, size: skimage.morphology.dilation(bin_m, skimage.morphology.disk(size)),
        'EROSION': lambda bin_m, size: skimage.morphology.erosion(bin_m, skimage.morphology.disk(size)),
        'MEDIANFILTERING': lambda bin_m, size: skimage.filters.median(bin_m, np.ones((size, size)))
    }

    def __init__(self, warning, coord, filter_data):
        """Initialize Warn.

        Parameters
        ----------
        warning : np.array
            Warn level for every point of input map.
        coord : np.array
            Coordinates of warning map.
        warn_levels : list
            Warn levels that define the bins in which the input_map will be classified in.
        """
        self.warning = warning
        self.coord = coord
        self.warn_levels = filter_data.warn_levels

    @classmethod
    def from_map(cls, input_map, coord, filter_data):
        """Generate Warn object from np.array.

        Parameters
        ----------
        input_map : np.array
            2d map of values which are used to generate the warning.
        coord : np.array

        filter_data : dataclass
            dataclass consisting information on how to generate the warning (operations and properties)

        Returns
        ----------
        warn : Warn
            Generated Warn object including warning
        """
        binned_map = cls.bin_map(input_map, filter_data.warn_levels)
        warning = cls.filter_algorithm(binned_map, filter_data, cls.filtering_operations)
        if filter_data.change_sm:
            warning = cls.change_small_regions(warning, filter_data.size_sm)
        return cls(warning, coord, filter_data)

    @staticmethod
    def bin_map(input_map, warn_levels):
        """Bin every value of input map into given warn levels.

        Parameters
        ----------
        input_map : np.array
            Array containing data to generate warning of.
        warn_levels : np.array
            Array containing data to generate warning of.

        Returns
        ----------
        binned_map : np.array
            Map of binned values, same shape as input
        """
        if np.min(input_map) < np.min(warn_levels):
            LOGGER.warning('Values of input map are smaller than defined warn levels. '
                           'Please set the warn levels lower or check input map.')
        if np.min(input_map) > np.min(warn_levels):
            LOGGER.warning('Values of input map are larger than defined warn levels. '
                           'Please set the warn levels higher or check input map.')
        return np.digitize(input_map, warn_levels) - 1  # digitize lowest bin is 1

    @staticmethod
    def filtering(d, warn_reg, curr_lvl, filter_data, filtering_operations):

        if filter_data.gradual_decr:
            pts_curr_lvl = np.bitwise_or(warn_reg, d >= curr_lvl)  # select also higher warn levels to grad. decrease
        else:
            pts_curr_lvl = d == curr_lvl  # only select current warn level points -> no gradual decrease
        binary_regions = np.where(pts_curr_lvl, curr_lvl, 0)  # set everything but selected points to 0

        for i, op in enumerate(filter_data.operations):
            binary_regions = filtering_operations[op](binary_regions, filter_data.sizes[i])

        return binary_regions

    @staticmethod
    def filter_algorithm(bin_map, filter_data, filtering_operations):
        """Generate contiguous regions of thresholded data.

        Parameters
        ----------
        d_thrs : np.array
            Thresholded data to generate contiguous regions of.
        """
        max_warn_level = np.max(bin_map)
        if max_warn_level == 0:
            return np.zeros_like(bin_map)

        warn_regions = 0
        # iterate from highest level to lowest (0 not necessary, because rest is level 0)
        for j in range(max_warn_level, 0, -1):
            w_l = Warn.filtering(bin_map, warn_regions, j, filter_data, filtering_operations)
            # keep warn regions of higher levels by taking maximum
            warn_regions = np.maximum(warn_regions, w_l)
        return warn_regions

    @staticmethod
    def increase_levels(warn, size):
        """

        :param warn:
        :param size:
        :return:
        """
        # increase levels of too small regions to max level of this warning
        labels = skimage.measure.label(warn)
        for i in range(np.max(labels)):
            cnt = np.count_nonzero(labels == i)
            if cnt <= size:
                warn[labels == i] = np.max(warn, axis=(0, 1))
        return warn

    @staticmethod
    def set_new_levels(warn, size):
        """

        :param warn:
        :param size:
        :return:
        """
        # correct the max_lvl regions generated before down,
        # until the new regions with it are large enough
        for i in range(np.max(warn), np.min(warn), -1):
            level = copy.deepcopy(warn)
            level[warn != i] = 0
            labels = skimage.measure.label(warn)
            for j in range(len(np.unique(labels)) + 1):
                cnt = np.count_nonzero(labels == j)
                if cnt <= size:
                    warn[labels == j] = i - 1
        return warn

    @staticmethod
    def change_small_regions(warning, size):
        """Change regions smaller than defined threshold from warning to surrounding warn level.

        Parameters
        ----------
        warning : np.array
            Warning map of which too small regions are changed to surrounding.
        size_thr : int
            Threshold defining too small regions (number of grid points).

        Returns
        ----------
        warning : np.array
            Warning without too small regions.
        """
        warning = warning + 1  # 0 is regarded as background in labelling, + 1 prevents this
        warning = Warn.increase_levels(warning, size)
        warning = Warn.set_new_levels(warning, size)
        warning = warning - 1
        return warning
